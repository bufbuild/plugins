# Contributing

## Description

Currently, the Buf development team supports this project and creates new plugins (or new versions) for users of the Buf Schema Registry.
This document provides details for Buf developers on how to contribute to this repository.

## Building

The build requires the following:

* [Go](https://go.dev/dl/) (1.18+)
* [Buf](https://github.com/bufbuild/buf)
* [yq](https://github.com/mikefarah/yq)

### Makefile targets

* Build all plugin Docker images (including prerequisites): `make` or `make build`.
* Run integration tests against Docker images: `make test`.
* Remove intermediate state from previous builds: `make clean`.
* Push built plugins to the BSR (currently locked down to CI/CD): `make push`.
* Build and test an individual plugin:
  * Specific version: `make test PLUGINS="connect-go:v0.4.0"`
  * Latest version: `make test PLUGINS="connect-go:latest"`.
  * All versions: `make test PLUGINS="connect-go"`.

## Creating a new plugin

Plugins are found in the top-level `library` or `contrib` directories, depending on their level of support by the Buf team.

To create a new plugin, add a new folder matching the last component of the plugin's name and its version (i.e. `mkdir -p library/plugin-name/vX.Y.Z`) and add a `buf.plugin.yaml` / `Dockerfile` / `.dockerignore` to the newly created directory.
To verify the plugin builds properly, run `make PLUGINS="<plugin-name>"` to build the Docker image and `make test PLUGINS="<plugin-name>"` to verify code generation for the plugin using some basic APIs stored in `tests/testdata/images/`.

When a plugin is executed for the first time, it will create the following file(s):

* `tests/testdata/buf.build/library/<plugin-name>/<plugin-version>/<image>/plugin.sum`

After verifying the generated code from the plugin in `tests/testdata/buf.build/library/<plugin-name>/<plugin-version>/<image>/gen`, these file(s) should be checked into source control to ensure the CI tests pass.
This file contains a directory checksum of the generated code for the plugin and is checked in to ensure that generated code matches the expected output.

## Plugin Authoring Best Practices

* Use multi-stage builds to optimize image size. (Recommended to use `scratch` or `debian:bullseye-YYYYMMDD-slim` as runtime images).
* Always include a [.dockerignore](https://docs.docker.com/engine/reference/builder/#dockerignore-file) alongside the Dockerfile to minimize the Docker build context size (and avoid cache misses during builds). See the following for some examples based on the Protobuf plugin language type:
    * Generic: [library/go/v1.28.0/.dockerignore](https://github.com/bufbuild/plugins/blob/9595dfbad2ef0476b2aab7e0ea5e6d9de15ddb51/library/go/v1.28.0/.dockerignore)
    * NPM/Node: [library/protobuf-es/v0.1.1/.dockerignore](https://github.com/bufbuild/plugins/blob/9595dfbad2ef0476b2aab7e0ea5e6d9de15ddb51/library/protobuf-es/v0.1.1/.dockerignore)
    * Go (pre-Go modules): [library/twirp-go/v8.1.2/.dockerignore](https://github.com/bufbuild/plugins/blob/9595dfbad2ef0476b2aab7e0ea5e6d9de15ddb51/library/twirp-go/v8.1.2/.dockerignore)
* Builds should be reproducible (if possible). All Docker images used for builds should use a specific label (i.e. `debian:bullseye-YYYYMMDD` instead of `debian:bullseye` or `debian`).
    * NPM/Node: A `package.json` and `package-lock.json` file should be checked in and `npm ci` should be used during installation to ensure consistent dependencies are installed.
    * Go: Compilation should use `-trimpath`.
* A `buf.plugin.yaml` should include the following:
    * `source_url`: Path to the source code URL for the Protobuf plugin.
    * `description`: Description of the plugin (shown to the user in the BSR).
    * `output_languages`: The output language types generated by the plugin. See the [PluginLanguage](https://github.com/bufbuild/buf/blob/c8fc1a2a8176c69a1176a18741506181fc1edbaf/proto/buf/alpha/registry/v1alpha1/plugin_curation.proto#L30-L47) enum for existing languages. Open a GitHub issue in the [Buf CLI](https://github.com/bufbuild/buf) if the output language isn't found for a plugin.
    * If the plugin outputs JavaScript/TypeScript or Go, it is recommended to add a `runtime` section so the plugin can be used with the BSR remote registries. See the `connect-go` or `connect-web` plugins for an example. This is an advanced topic, so feel free to reach out on [Slack](https://buf.build/links/slack) for more information.
* Plugins should include a `source.yaml` at the top-level directory (i.e. `library/my-plugin`) with instructions for how to detect when new plugins are available.

## CI/CD

PR builds use [tj-actions/changed-files](https://github.com/tj-actions/changed-files) to determine which plugin(s) need to be rebuilt.
See [.github/workflows/pr.yaml](https://github.com/bufbuild/plugins/blob/9595dfbad2ef0476b2aab7e0ea5e6d9de15ddb51/.github/workflows/pr.yml#L23-L36) and [cmd/dependency-order/main.go](https://github.com/bufbuild/plugins/blob/main/cmd/dependency-order/main.go) for more details.
Note that some files (`Makefile`,`tests/*.go`,`tests/testdata/images/*.gz`) require all plugins to be rebuilt.
Builds on the main branch don't use this optimization (we use concurrency controls to limit parallel builds and would need to determine what changed since the last published build).
We may optimize this in the future.

We use a combination of a custom command ([cmd/fetcher/main.go](https://github.com/bufbuild/plugins/blob/main/cmd/fetcher/main.go)) and Dependabot to keep dependencies up to date in the project.
The `fetcher` command will use `source.yaml` files in each plugin to determine if new plugin versions are available.
Dependabot is used to determine if base Docker images are up-to-date with bug/security fixes.

### Caching

We currently use [Buildkit registry caching](https://github.com/moby/buildkit#registry-push-image-and-cache-separately) to optimize build times for PR and main branch builds.
Main branch builds publish Docker images to:

* `ghcr.io/bufbuild/plugins-<org>-<name>:<version>` (Plugin image)
* `ghcr.io/bufbuild/plugins-<org>-<name>:<version>-buildcache` (Registry cache with `mode=max`)

These images are used only for caching - the authoritative images used for plugin execution are pushed to the BSR.
Untagged versions of these cached images can be cleaned up at any time (only the latest tagged versions are used).

During development, we've encountered a number of issues which lead to cache misses and in turn cause unnecessary revisions of plugins to be published to the BSR.
Workarounds are in place for the majority of issues, however we should be careful to ensure build reproducibility.
One critical change to the build images is the removal of `--build-arg` arguments in base images and the migration from `type=inline` to `type=registry` caching.
See [PR #41](https://github.com/bufbuild/plugins/pull/41) and [PR #38](https://github.com/bufbuild/plugins/pull/38) for the gory details.

## Updates

### Creating a new plugin version

If the `fetcher` command opens a PR for a new version of an existing plugin, there are currently some manual steps required before merging:

1. Check out the PR locally (i.e. `gh pr checkout <num>`).
2. Perform any manual updates to `package.json`, `go.mod`, or other files (if used by the plugin).
   If NPM or Go dependencies change, ensure that `npm i` or `go mod tidy` are run to ensure that the `package-lock.json` or `go.sum` files are kept up to date.
3. Double check version numbers in `plugin.yaml` or other files to ensure they are bumped.
   Often times, there may be dependencies (plugin or runtime dependencies) which need to be updated.
4. Run `make PLUGINS="<plugin-name>"` and `make test PLUGINS="<plugin-name>"` to build the plugin and run the unit tests.
   It is expected that the tests will fail with a directory checksum mismatch (because the `plugin.sum` file doesn't exist).
   Perform a manual inspection of the generated code for the new version of the plugin under `tests/testdata/library/<plugin-name>/<version>/*/gen` to ensure it looks correct.
   It may be helpful to diff a previous version of the plugin's generated code to the new version's to verify expected changes are included.
5. Add the `plugin.sum` files for the new version of the generated code to source control and request a PR review for any updates.

### Updating Docker Base Images

We've only included a representative set of Docker images in the [.github/dependabot.yml](https://github.com/bufbuild/plugins/blob/main/.github/dependabot.yml) file for each type of plugin (Node, Go, etc.).
If Dependabot detects an update to a base image, we should update all plugins to use the new base image either with a separate PR or a manual update to the Dependabot PR.

## Local Testing

When testing locally, you may wish to build for a different architecture or push plugins to a different instance of the BSR.
For example:

```
$ make push BUF_PLUGIN_PUSH_ARGS="--override-remote bufbuild.internal"
```

This command can also be used to publish to other instances of the BSR.
This will build with the default architecture of the system by default.
To specify a different architecture (i.e. x86_64), specify the `DOCKER_BUILD_EXTRA_ARGS="--platform linux/amd64"` argument to the build.
