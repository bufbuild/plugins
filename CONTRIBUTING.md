# Contributing

## Description

Currently, the Buf development team supports this project and creates new plugins (or new versions) for users of the Buf Schema Registry.
This document provides details for Buf developers on how to contribute to this repository.

## Building

The build requires the following:

* [Go](https://go.dev/dl/) (1.19+)
* [Buf](https://github.com/bufbuild/buf) (1.11.0+)
* [yq](https://github.com/mikefarah/yq)

### Makefile targets

* Build all plugin Docker images (including prerequisites): `make` or `make build`.
* Run integration tests against Docker images: `make test`.
* Remove intermediate state from previous builds: `make clean`.
* Push built plugins to the BSR (currently locked down to CI/CD): `make push`.
* Build and test an individual plugin:
  * Specific version: `make test PLUGINS="connect-go:v0.4.0"`
  * Latest version: `make test PLUGINS="connect-go:latest"`.
  * All versions: `make test PLUGINS="connect-go"`.

## Creating a new plugin

Plugins are found in the top-level `plugins` directory.

To create a new plugin, add a new folder with the plugin's organization, name, and version (i.e. `mkdir -p plugins/<org>/<name>/<version>`) and add a `buf.plugin.yaml` / `Dockerfile` / `.dockerignore` to the newly created directory.
To verify the plugin builds properly, run `make PLUGINS="<org>/<name>"` to build the Docker image and `make test PLUGINS="<org>/<name>"` to verify code generation for the plugin using some basic APIs stored in `tests/testdata/images/`.

When a plugin is executed for the first time, it will create the following file(s):

* `tests/testdata/buf.build/<org>/<name>/<version>/<image>/plugin.sum`

After verifying the generated code from the plugin in `tests/testdata/buf.build/<org>/<name>/<version>/<image>/gen`, these file(s) should be checked into source control to ensure the CI tests pass.
This file contains a directory checksum of the generated code for the plugin and is checked in to ensure that generated code matches the expected output.

## Plugin Authoring Best Practices

* Use multi-stage builds to optimize image size. (Recommended to use `scratch` or [distroless](https://github.com/GoogleContainerTools/distroless) as runtime images).
* Always include a [.dockerignore](https://docs.docker.com/engine/reference/builder/#dockerignore-file) alongside the Dockerfile to minimize the Docker build context size (and avoid cache misses during builds). See the following for some examples based on the Protobuf plugin language type:
    * Generic: [plugins/protocolbuffers/go/v1.28.0/.dockerignore](plugins/protocolbuffers/go/v1.28.0/.dockerignore)
    * NPM/Node: [plugins/bufbuild/es/v0.1.1/.dockerignore](plugins/bufbuild/es/v0.1.1/.dockerignore)
    * Go (pre-Go modules): [plugins/twitchtv/twirp/v8.1.2/.dockerignore](plugins/twitchtv/twirp/v8.1.2/.dockerignore)
* Builds should be reproducible (if possible). All Docker images used for builds should use a specific label (i.e. `debian:bullseye-YYYYMMDD` instead of `debian:bullseye` or `debian`).
    * NPM/Node: A `package.json` and `package-lock.json` file should be checked in and `npm ci` should be used during installation to ensure consistent dependencies are installed.
    * Go: Compilation should use `-trimpath`.
    * Plugins should include a `source.yaml` at the top-level directory (i.e. `plugins/<org>/<name>`)
    with information on how to detect new plugin versions.

### `buf.plugin.yaml` file

A `buf.plugin.yaml` file captures metadata about the plugin. It includes mandatory and optional
fields that are displayed on the individual plugin page and the BSR plugin homepage at
https://buf.build/plugins.

Note, although some fields are optional, it is suggested to include as many as possible.

**Mandatory:**

* `version`: The YAML configuration version, must be `v1`.
* `name`: the plugin identity with format `{remote}/{organization_name}/{plugin_name}`.
* `plugin_version`: the plugin version with format`v{semver}`, the `v` prefix is required and the
  version must be valid [semantic versioning](https://semver.org/).

**Optional:**

* `source_url`: Path to the source code URL for the Protobuf plugin.
* `description`: Description of the plugin (shown to the user in the BSR).
* `output_languages`: The output language types generated by the plugin. See the [PluginLanguage](https://buf.build/bufbuild/buf/docs/main:buf.alpha.registry.v1alpha1#buf.alpha.registry.v1alpha1.PluginLanguage) enum for existing languages. Open a GitHub issue in the [Buf CLI](https://github.com/bufbuild/buf) if the output language isn't found for a plugin.
* `spdx_license_id`: The license id for the plugin from https://spdx.org/licenses/.
* `license_url`: The URL to the license for the release of the plugin.
* If the plugin outputs JavaScript/TypeScript or Go, it is recommended to add a `runtime` section so the plugin can be used with the BSR remote registries. See the `connect-go` or `connect-web` plugins for an example. This is an advanced topic, so feel free to reach out on [Slack](https://buf.build/links/slack) for more information.

## CI/CD

Builds use [tj-actions/changed-files](https://github.com/tj-actions/changed-files) to determine which plugin(s) need to be rebuilt.
See [.github/workflows/pr.yaml](.github/workflows/pr.yml) and [internal/cmd/changed-plugins/main.go](internal/cmd/changed-plugins/main.go) for more details.

We use a combination of a custom command ([cmd/fetcher/main.go](cmd/fetcher/main.go)) and Dependabot to keep dependencies up to date in the project.
The `fetcher` command will use `source.yaml` files in each plugin to determine if new plugin versions are available.
Dependabot is used to determine if base Docker images are up-to-date with bug/security fixes.

### Caching

Main branch builds publish Docker images to:

* `ghcr.io/bufbuild/plugins-<org>-<name>:<version>` (Plugin image)

These images are used only for caching - the authoritative images used for plugin execution are pushed to the BSR.
Untagged versions of these cached images can be cleaned up at any time (only the latest tagged versions are used).

During development, we've encountered a number of issues which lead to cache misses and in turn cause unnecessary revisions of plugins to be published to the BSR.
Workarounds are in place for the majority of issues, however we should be careful to ensure build reproducibility.

## Updates

### Creating a new plugin version

If the `fetcher` command opens a PR for a new version of an existing plugin, most steps are automated but make sure to review the following:

* The versions of dependencies on plugins and runtime dependencies under `registry:`.
* Ensure that the Docker base images (both `build` and runtime image) are updated to the latest.
* Versions of dependencies in `package.json` or `go.mod` files.
* The diff of generated code between the previous version and new version (displayed in GitHub Actions log for the "Fetch latest versions" workflow.)

### Updating Docker Base Images

We've only included a representative set of Docker images in the [.github/dependabot.yml](.github/dependabot.yml) file for each type of plugin (Node, Go, etc.).
If Dependabot detects an update to a base image, we should update all plugins to use the new base image either with a separate PR or a manual update to the Dependabot PR.

## Local Testing

When testing locally, you may wish to build for a different architecture or push plugins to a different instance of the BSR.
For example:

```
$ make push BUF_PLUGIN_PUSH_ARGS="--override-remote bufbuild.internal"
```

This command can also be used to publish to other instances of the BSR.
This will build with the default architecture of the system by default.
To specify a different architecture (i.e. x86_64), specify the `DOCKER_BUILD_EXTRA_ARGS="--platform linux/amd64"` argument to the build.
